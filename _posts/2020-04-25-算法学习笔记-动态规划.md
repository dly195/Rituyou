---
layout: post
title:  "算法学习笔记-动态规划"
date:   2020-04-25 18:30:00
categories: studying
tags: [算法]
excerpt: 小白动态规划学习笔记
---

算法小白学习递归算法的个人理解。权当记录。


#### 递归算法
学习动态规划，不能不讲递归，因为递归和动态规划有很多相似之处，而且递归对很多人来说是非常容易理解的。

##### 递归定义
简单的来说，递归就是把复杂的大问题不断地拆成可以被轻松解决的小问题，通过不断的解决小问题从而获的原问题的解。

##### 递归的局限性与优化

```
斐波那契数列：给定前两位数，从第三个数开始，每个数等于前两位数的和，求第N位数字是多少
```
我们以斐波那契数列为例，开始分析。

按照递归的解法：
我们在计算 F(N)时，只需要将N分解成N-1和N-2，然后再不断地分解，直到分解到F(0)或F(1)即可。
![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge5vp84mw3j30q70h8400.jpg)
我们将其画成树的形式来理解
很明显，我们在计算F(N)时，除了F(N-1)以外，所有的数字都出现了重复计算，注意我们这里不单纯是重复计算了F(N-2)，而是重复计算了N-2拆解的所有步骤。
所以我们得出一个结论：**普通的递归算法会导致出现重复计算**

为了解决重复计算的问题，我们想到的方案就是利用容器把计算后的结果装起来，每次计算之前我们先检查容器内是否已有答案，如果有则不需要再重复计算，即利用空间获取时间。这种方案叫做**记忆化搜索**。

##### 递归的特点
通过对斐波那契数列递归解法的分析，总结出递归算法的特点

```
1. 具有重叠子问题
2. 可以使用记忆化搜索优化
```

#### 动态规划

我们知道递归算法是将重复地调用同一个函数并不断修改其参数，直到参数满足了一定的终止条件。而程序在调用函数的过程中，也会产生一些额外的消耗。比如说在函数执行完毕之前，内存里会一直保存着这个函数。所以递归在不断回调函数的过程中也产生一些额外的消耗。

为了避免这种额外的消耗，我们希望能够在一个函数中就完成“递归”的过程。所以就出现了这么一种解决方案：**使用一个容器，将拆解的子问题的答案储存下来，并通过从容器中不断取已知子问题的解来求解未知的子问题**。这就是动态规划。

##### 动态规划定义

将原问题拆成若干子问题，同时保存子问题的答案，使得每个子问题只需求解一次，最终获得原问题答案的算法。

##### 动态规划的特点

我们知道动态规划一定意义上可以说是递归与记忆化搜索的优化版本，所以它也具有递归和记忆化搜索的特点

```
1. 拥有重复的子问题
2. 有一个容器记录已知子问题的解
```

##### 动态规划可以解决什么问题

我们知道了可以用递归与记忆化搜索的题目基本上行都可以用动态规划来优化。具体来看，动态规划都能解决哪些问题呢 

```
1. 计数型（求多少）
2. 最值（最大最小，最长最短）
3. 存在性（是否可以，能不能赢）
```
并不是说这三类题都可以用动态规划来解，二是在遇到这三类题的时候，我们要考虑一些动态规划的算法

#### 如何使用动态规划解题

##### 确定状态

###### 状态是什么：

我理解的**状态就是指我们的递归函数的含义，包括函数求解的是什么问题，需要什么参数**，也有人说**状态指的是dp数组的下标的含义**。我认为这两种解释都是妥帖的。

###### 状态如何确定

 如果我们状态理解是递归函数的含义，那么怎么确定状态也就不言而喻了： 

 ```
 1. 明确最后一步问题是什么，也就是最终我们要求的解是什么
 2. 子问题是什么，哪个问题是可以被不断分解成小问题的
 ```
  
##### 状态转移方程

状态转移方程说白了就是，**我们求解的问题与其子问题的关系**。
例如斐波那契数列中，F(N)与F(N-1)和F(N-2)的关系就是:
F(N) = F(N-1) + F(N-2)
也就是F(N)的解是子问题F(N-1) 和 F(N-2)的解相加的和

##### 初始条件和边界情况

初始条件是**我们通过人工可以定下来的或者状态转移计算不出来的需要我们先计算出来的子问题的解**，例如斐波那契数列中，我们需要先给定前两个数的值。
边界条件通俗的讲就是**保证记录计算过程中不要数组越界**

##### 计算顺序

有的视频上说，递归是从定向下的，而动态规划是从下向上的计算。在这一点上，我不是这样认为的。不论是递归还是动态规划，它的计算方向并不是一定的，而是遵循着**在计算等式左边的解时，等式右边的解必须是已经计算完整的**。也就是我们按照0到N，还是N到0的顺序循环计算，取决于F(N)和F(N-1)的推导关系。

我认为掌握好这几个步骤就可以去刷动态规划的题目了，从实践中培养出题感。动态规划的难点在于 状态的确定和状态转移方程 只要把这两个点把握住哦了，问题就变得很简单了。

作为算法小白，最好还是能从经典的背包问题入手.


